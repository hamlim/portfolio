---
title: 'Why I choose Tailwind CSS'
date: '10/28/2024'
description:
  "Everyone I talk to who's tried Tailwind loves it. Folks who have not yet
  tried it dismiss it. Why is there so much resistance toward Tailwind?"
image: '/images/blog/why-tailwind.png'
width: '1600'
height: '800'
---

Early in my career, my background was in web development with a focus on HTML &
CSS. When I first was introduced to Tailwind I was initially skeptical. However,
using it in different projects, I quickly realized that the advantages outweigh
the disadvantages.

## Utility first approach

One of the main differences of Tailwind is the utility first approach. Tailwind
allows you to leverage predefined class names directly in your code.

This is the first point of contention for folks who prefer a modular approach to
CSS. I felt this way at first even with experience using both utility class and
modular approaches. Those who are really deeply interested in CSS like the
freedom that comes with a modular approach as it feels fresh and creates a
separation of concerns.

The most important benefit Tailwind provides leverages the utility class first
approach. Tailwind classes are tied to single or in some cases two or three CSS
declarations. This allows the style sheet to only record declarations once.

For example, with modular styles you will declare declarations like
`display: flex` or `margin: 1rem` repeatedly in classes where using Tailwind
declarations are recorded once in your style sheet reducing the cost of size of
the overall size of the styles you need to bundle to your browser.

```jsx
// Tailwind - These two classes are reused every time you use these CSS declarations
.m-4 {
  margin: 1rem;
}
.flex {
  display: flex;
}

// Modular - We will find ourselves writing declarations more than once
.MyClass {
  display: flex;
  margin: 1rem;
}

.MyOtherClass {
  display: flex;
  flex-direction: column;
  margin: 1rem;
}

```

By definition, we will always have leaner style sheets using Tailwind due to
this approach. We can do more with recording less and allows us to move faster
without the need to be concerned about how many styles we are using.

The utility first approach makes it easier for users to adhere to standards with
themes. By providing classes out of the box, it is more likely that users of
your system will stick to the conventions set by the team. When given the chance
to write a new style sheet, engineers are more likely try to solve a problem
using unique values or different units and not sticking to variables and best
practices.

Providing class names for engineers who may be less confident with CSS who may
need to set layout or make small CSS tweaks, are more likely to be successful
when they don't have to understand the entire ecosystem of style sheets to get
their feature across the finish line.

Tailwind still provides flexibility to break out of any utility class and
provide custom declarations:

```jsx
<div className="grid grid-cols-[200px,1fr]">...</div>
```

## Customization

Tailwind supports endless customization, you can easily customize your
configuration:

- Specify files that use Tailwind
- Themes
- Screen sizes
- Spacing
- Colors
- Typography
- Countless plugins
- Reusable presets

Anything you can do in CSS you can configure Tailwind to handle.

## Prototyping

It is a tool that allows you to more rapidly prototype because you're given some
presets that allow you to hit the ground running right away. It's important to
remember though Tailwind is not bootstrap. Yes it comes out of the box
unopinionated and it's a strong prototyping tool but the ability to customize it
so heavily is there for you to form opinions on its use and how the application
should leverage it.

## Performance

Where Tailwind shines most brightly is its ability to do all the hard parts of
performance for you. Without Tailwind traditionally when running your
application against performance metrics, (especially large enterprise
applications) you will likely have to determine which CSS is critical or above
the fold. Typically teams have to create a solution to the`<head/>` with
critical CSS and immediately hydrate critical CSS. All of this is taken care of
for you in Tailwind.

## Maintainability

Tailwinds

## Large community and ecosystem

Tailwind currently has over 82K stars on GitHub and is actively growing. There's
huge community support around this styling library with many trusted
contributors and active [plugins](https://tailwindcss.com/docs/plugins).

Simply put, being a successful developer or engineer reuqires a willing to try
new things.

Yes, Tailwind does take some of the hard parts of CSS and simplify them. CSS
specs are becoming easier and easier to use and we tend to praise these newer
solutions like flex, grid, etc. We should look to alternative framework
approaches the same. Embrace change and new tools by trying them out for a
period of time in applications or side projects and add another tool to our
toolkit. For me currently, I've been using Tailwind CSS whenever I spin up a new
app. üòÅ I do still use CSS and regular styles in my quick
[Codepen's](https://codepen.io/scottykaye) and when Tailwind might not have a
class out of the box for prototyping.

####

The biggest argument and longest running joke against Tailwind are super long
class names.

There are many approaches to managing this:

- Using a [clsx](https://www.npmjs.com/package/clsx) function to create arrays
  of strings to manage organization.
- Creating constants and use them in your class names or clsx functions.
- Using sorting mechanisms to reduce friction of class name changes.

This allows you the opportunity to organize class names similar to how you may
want to organize modular styles.
